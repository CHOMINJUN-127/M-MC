# M&MC

+ 의학 전용 웹 사이트

+ M&MC는 __Medical & Machine Connection__ 의 약자로, 의료 __(Medical)__ 와 컴퓨터 __(Computer)__ 를 연결한다는 의미를 담고 있다.
------
## 📌 프로젝트 개요

이 프로젝트는 __생명과학Ⅰ 수업에서 딥러닝을 활용한 의료영상 분석 사례를 조사·발표한 경험__ 에서 출발하였다.
조사 과정에서 딥러닝을 활용할 경우, 기존 방식보다 __약 40분 이상 빠르게 질병의 원인을 파악할 수 있다__ 는 점이 인상 깊었다. 이를 통해 인공지능 기반 의료 시스템이 실제 진료에 활용된다면, 환자는 더 빠르게 치료를 받을 수 있고 의사는 더 많은 환자를 효율적으로 진료할 수 있을 것이라고 판단하였다.

이러한 문제의식을 바탕으로, __인공지능 프로그래밍을 의료 분야에 적용한 웹 서비스를 직접 구현해 보고 싶다는 목표__ 를 가지게 되었고, 그 결과로 M&MC 의학 웹 사이트를 기획하게 되었다.

## 🎯 프로젝트 목적

1. __의학을 잘 모르는 일반 사용자도 질병에 대해 ‘이해하며 배울 수 있는 웹’ 구현__ 
     많은 사람들이 질병의 이름이나 증상은 알고 있지만,
     _왜 그 질병이 발생하는지, 어떤 원리로 진행되는지_ 에 대해서는 잘 알지 못한다는 점에 주목하였다.

2. __의료 계열 및 관련 진로를 희망하는 학생들에게 학습 도구로 활용 가능한 웹 제작__
     의료 분야에 관심 있는 학생들이 참고 자료로 활용할 수 있는
   __의학 정보 기반 웹 플랫폼__ 을 만드는 것도 중요한 목적 중 하나였다.

## 🔄 방향 전환 배경

초기에는 __딥러닝·머신러닝 모델을 직접 구현하여 의료 데이터를 분석하는 웹__ 을 목표로 하였다.
그러나 당시 딥러닝과 머신러닝에 대한 체계적인 학습 경험이 부족했고,
모델 구조와 학습 과정에 대한 이해도 역시 충분하지 않아 __실제 구현은 현실적으로 매우 어려운 상황__ 이었다.

이 과정에서 1학년 통합과학 수업 시간에 들었던
__AI를 활용하여 백신을 개발한 사례 발표__ 가 떠올랐고,
“복잡한 모델을 직접 구현하는 것보다, 내가 이미 경험해 본 웹 개발을 기반으로 인공지능을 활용하자”는 방향으로 생각을 전환하게 되었다.

그 결과, __딥러닝 모델을 직접 만드는 대신 API 기반 인공지능을 활용한 의학 전용 웹__ 을 제작하기로 결정하였다.

## 🛠️ 구현 내용

+ __프로젝트 형태__: 의학 전용 AI 웹 사이트 (M&MC)

+ 접근 방식:
            +오픈소스 모델 직접 구현 → 구현 난이도로 인해 중단
            + __무료로 사용 가능한 API Key를 활용한 인공지능 기능 구현__

+ __질병 선정__: 총 __7가지 질병 선정__
+ __제공 정보 구성__
  
   __1. 각 질병별 설명 자료(PDF)__
 
   __2. 관련 유튜브 영상__
 
   __3. 기사 자료__
 
   __4. 질병 발생 원인 및 특징 정리__

이를 통해 사용자는 단순 검색이 아닌,
__하나의 웹 환경에서 질병에 대한 다양한 형태의 정보를 종합적으로 학습__ 할 수 있도록 구성하였다.


## ⚕️선정한 7가지 질병과 설명

### __🧠 뇌졸중__

뇌혈관이 막히거나 터지면서 뇌에 산소 공급이 차단되는 질환이다.
고혈압, 흡연, 당뇨와 같은 생활 습관 요인이 큰 영향을 미치지만,
많은 사람들이 단순히 “갑자기 쓰러지는 병” 정도로만 인식하고 있어 원인 설명이 필요하다고 판단하였다.

### __🫁 폐암 __

흡연뿐 아니라 대기오염, 직업적 노출 등 다양한 요인에 의해 발생한다.
암이라는 단어는 익숙하지만, __정상 세포가 어떻게 변형되는지__ 에 대한 이해는 부족하다고 느껴 선정하였다.

### __🤧 폐렴__

감염성 질환으로 알려져 있지만, 고령자나 면역력이 약한 사람에게 왜 치명적인지에 대한 설명이 부족한 경우가 많다.
질병의 원리와 위험 요인을 함께 설명하고자 포함하였다.

### __❤️ 심정질환__

심장의 구조적·전기적 이상으로 발생하는 질환으로,
돌연사의 원인이 되기도 하지만 정확한 발생 메커니즘은 잘 알려져 있지 않다.

### __👴 알츠하이머__

단순한 노화 현상이 아니라 뇌 신경세포의 퇴화 과정이라는 점을 설명하기 위해 선정하였다.
질병과 노화를 구분하는 교육적 의미가 크다고 판단하였다.

### __💉 당뇨병__

혈당 조절 이상이라는 결과만 알려져 있을 뿐,
인슐린의 역할과 대사 과정에 대한 이해는 부족하다고 느껴 포함하였다.

### __🆘 자살__

개인의 문제가 아니라 __사회적·심리적·의학적 요인이 복합적으로 작용하는 문제__ 라는 점을 알리고자 선정하였다.
원인과 위험 요인을 정보 중심으로 다루는 것을 목표로 하였다.


## 👨‍💻 코드 구조 및 상세 설명

M&MC는 __프론트엔드(웹 UI)__ 와 __백엔드(Flask 서버 + AI API)__ 가 명확히 분리된 구조로 설계되었다.
각 코드의 목적은 _“기능 구현”_ 이 아니라 “의학 정보를 더 쉽게 전달하기 위한 흐름 제어”에 있다.

## 🏗️ 전체 시스템 구조

![웹 설명](https://github.com/CHOMINJUN-127/M-MC/blob/main/%EC%9B%B9%20%EC%84%A4%EB%AA%85.png)

이 구조를 통해 __웹 → 서버 → AI → 웹__ 의 흐름을 직접 구현하였다.

## Frontend Explanation

### 📚1. 프론트엔드의 역할

본 프로젝트의 프론트엔드는 __사용자와 AI 챗봇 간의 상호작용을 담당하는 UI 계층__ 이다.
사용자로부터 질문을 입력받고, 서버로 요청을 전송하며, 응답을 화면에 시각적으로 출력하는 역할을 수행한다.

프론트엔드는 __HTML, CSS, JavaScript__ 로 구성되어 있으며, 단일 페이지에서 모든 동작이 이루어진다.

### 👩‍🏫2. HTML 구조 설명

__HTML__ 은 챗봇 인터페이스의 뼈대 역할을 한다.
전체 구조는 다음과 같은 목적을 중심으로 설계되었다.

__채팅 메시지 출력 영역__

+ 사용자 질문과 AI 응답을 시간 순서대로 표시

+ 여러 메시지를 처리할 수 있도록 스크롤 가능한 구조

__입력 영역__

+ 사용자가 질문을 입력하는 텍스트 입력창

+ 엔터 또는 버튼 클릭을 통해 질문 전송 가능

__전송 버튼__

+ 입력된 질문을 서버로 전달하는 트리거 역할

이 구조를 통해 페이지 이동 없이 __하나의 화면에서 연속적인 대화가 가능하도록 구성__ 하였다.

### 👩‍🏫3. CSS 스타일링 설명

__CSS__ 는 기능을 방해하지 않는 선에서 __가독성과 구분성__ 을 높이는 데 초점을 두었다.

+ 사용자 메시지와 AI 응답을 서로 다른 스타일로 표현하여 대화 흐름을 직관적으로 인식 가능

+ 채팅 영역을 고정 크기로 설정하고 내부 스크롤을 사용하여 긴 대화도 자연스럽게 표시

+ 전체 레이아웃을 중앙 정렬하여 데스크톱 환경에서 안정적인 화면 구성 유지

디자인 자체보다 __정보 전달과 사용 편의성__ 을 우선으로 설계하였다.


### 👩‍🏫4. JavaScript 동작 로직 설명

__JavaScript__ 는 프론트엔드에서 가장 핵심적인 역할을 수행한다.

__4.1 사용자 입력 처리__

+ 입력창에 작성된 질문을 읽어온다.

+ 입력값이 비어 있는 경우 요청을 보내지 않도록 예외 처리한다.

__4.2 서버 요청 전송__

+ _fetch_ 를 사용하여 질문을 서버로 전송한다.

+ 요청 데이터는 _JSON_ 형식으로 구성하여 전달한다.

### 🖨️4.3 응답 수신 및 화면 출력

+ 서버로부터 받은 AI 응답을 채팅 메시지 형태로 화면에 추가한다.

+ 사용자 질문 → AI 응답 순서가 유지되도록 DOM을 동적으로 조작한다.

이 과정을 통해 __페이지 새로고침 없이 실시간 채팅이 가능한 구조__ 를 구현하였다.

### 📜5. 프론트엔드 설계 특징

+ 단일 HTML 파일 기반의 경량 구조

+ JavaScript를 이용한 비동기 통신 처리

+ UI와 로직을 명확히 분리하여 코드 가독성 유지

+ 서버 내부 동작을 알 필요 없이 응답 결과만 처리하는 구조

이로 인해 프론트엔드는 __AI 로직과 독립적으로 동작__ 하며, 유지보수와 확장이 용이하다.


### ☑️6. 프론트엔드 실행 흐름 요약

__1. 사용자가 질문을 입력한다.__

__2. JavaScript가 입력값을 읽어 서버로 전송한다.__

__3. 응답을 수신하면 채팅 영역에 출력한다.__

__4. 같은 과정을 반복하며 대화가 이어진다.__



### 1. Python과 연결되는 HTML 코드

##### (1) 사용자 입력창

<input type="text" id="userInput" placeholder="질문을 입력하세요">

__설명__

+ id="userInput"

→ __JavaScript__ 가 이 입력창을 __직접 선택__ 해서 사용자의 질문을 읽어오기 위한 식별자

이 요소 자체는 Python과 직접 연결되지 않지만

__Python으로 전달될 데이터의 출발점__ 이다.

##### (2) 전송 버튼

<button onclick="sendMessage()">전송</button>

__설명__

+ 버튼 클릭 시 __sendMessage()__ 함수 실행

+ 이 함수 안에서 __Python 서버로 요청을 보내는 코드가 실행됨__

+ 즉, 이 버튼이
  __사용자 행동 → JavaScript → Python__ 흐름의 시작점이다.


##### (3) 채팅 출력 영역

<div id="chatBox"></div>

__설명__

+ __Python__ 에서 반환된 응답이 __최종적으로 표시되는 영역__

+ __JavaScript__ 가 __Python__ 의 응답 데이터를 받아
  이 div 내부에 동적으로 추가한다.

### 2. Python과 직접 연결되는 JavaScript 코드

아래 코드는 __프론트엔드와 Flask를 실제로 연결하는 핵심 코드__ 다.


##### (1) 사용자 질문을 서버로 보내는 함수

function sendMessage() {
  const input = document.getElementById("userInput");
  const message = input.value;

  if (message.trim() === "") return;

  fetch("/ask", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ question: message })
  })
  .then(response => response.json())
  .then(data => {
    addMessage("AI", data.answer);
  });

  addMessage("User", message);
  input.value = "";
}


### 3. 코드 줄 단위 설명 (Python 연결 중심)

##### 1. 입력값 읽기

const input = document.getElementById("userInput");
const message = input.value;

+ HTML의 id="userInput" 요소에서 사용자 질문을 가져온다.

+ 이 값이 __Python으로 전달될 실제 데이터__ 이다.

##### 2. 빈 입력 방지

if (message.trim() === "") return;

+ 의미 없는 요청이 Python 서버로 전달되는 것을 방지

+ 서버 부하와 오류 가능성을 줄이기 위한 처리

##### 3. Python 서버로 요청 전송

fetch("/ask", {
  method: "POST",
  headers: {
    "Content-Type": "application/json"
  },
  body: JSON.stringify({ question: message })
})

__이 부분이 Python과 연결되는 핵심이다.__

+ /ask
  → Flask에서 정의된 Python API 엔드포인트

+ method: "POST"
  → Python의 @app.route("/ask", methods=["POST"])와 대응

+ body
  → { question: message } 형태로 JSON 데이터 전달
  → Python에서는 이 데이터를 받아 AI 처리 수행

__👉 이 한 줄로 프론트엔드와 파이썬이 연결된다.__


##### 4. Python 응답 수신

.then(response => response.json())
.then(data => {
  addMessage("AI", data.answer);
});


+ Python이 반환한 JSON 응답을 JavaScript가 수신

+ data.answer
  → Python 코드에서 생성한 AI 응답

+ 이 응답을 화면에 출력

##### 5. 사용자 메시지와 화면 갱신

addMessage("User", message);
input.value = "";

+ 사용자 질문을 즉시 화면에 출력

+ 입력창 초기화

### 4. Python과 연결되는 흐름 요약

수식처럼 정리하면 다음과 같다.

__사용자 입력 → HTML → JavaScript → fetch 요청 → Python(/ask) → 응답 → JavaScript → HTML 출력__

이 구조 덕분에:

+ 프론트엔드는 AI 로직을 전혀 몰라도 되고

+ Python은 UI 구조를 알 필요가 없다



----------



## Backend (Python / Flask) Explanation

### 1. 파이썬 백엔드의 역할

본 프로젝트에서 파이썬 백엔드는 __프론트엔드로부터 전달된 요청을 처리하고, AI 응답을 생성하여 반환하는 역할__ 을 수행한다.
Flask를 사용하여 웹 서버를 구성하였으며, 프론트엔드에서는 오직 API 요청만을 통해 파이썬 코드와 통신한다.

즉, 파이썬 코드는 __UI와 분리된 상태에서 로직과 연산만 담당__ 한다.



------------



### 2. 환경 변수 로드 및 API 키 관리

파이썬 코드에서는 __Groq API__ 키를 코드에 직접 작성하지 않는다.
__.env__ 파일에 저장된 값을 실행 시 불러와 사용한다.

이 구조의 목적은 다음과 같다.

+ API 키 외부 노출 방지

+ GitHub 업로드 시 보안 문제 예방

+ 실행 환경에 따라 키 변경 가능

API 키가 존재하지 않을 경우, 서버가 정상 동작할 수 없으므로 예외 처리를 통해 실행을 중단하도록 설계하였다.



---------



### 3. Flask 서버 초기화

__Flask__ 객체를 생성하여 웹 서버를 구성한다.

이 서버는 다음 두 가지 역할을 동시에 수행한다.

+ 프론트엔드 HTML 제공

+ AI 응답을 반환하는 API 서버 역할

또한 프론트엔드에서 fetch 요청이 정상적으로 동작하도록 CORS를 허용하였다.


---------------



### 4. 메인 페이지 라우트 (/)

루트 경로 __(/)__ 는 프론트엔드 __HTML__ 파일을 반환한다.

이 라우트의 특징은 다음과 같다.

+ 브라우저에서 서버 주소로 접속 시 바로 챗봇 UI 표시

+ 프론트엔드와 백엔드를 동일한 서버에서 제공하여 구조 단순화

이로 인해 별도의 정적 서버 없이도 프로젝트 실행이 가능하다.



-----------



### 5. AI 응답 처리 핵심 라우트 (/ask)

/ask 라우트는 __프론트엔드와 직접 연결되는 가장 중요한 파이썬 코드__ 이다.
앞에서 설명한 JavaScript의 fetch("/ask") 요청을 처리한다.



------------



### 6. /ask 라우트의 동작 흐름

이 엔드포인트는 다음 순서로 동작한다.

1. 프론트엔드에서 전달된 JSON 데이터를 수신

2. 질문 데이터가 존재하는지 확인

3. Groq API를 호출하여 AI 응답 생성

4. 생성된 응답을 JSON 형태로 프론트엔드에 반환

이 과정에서 파이썬은 __HTML이나 화면 구조를 전혀 알지 못하며,__
오직 텍스트 입력과 출력만을 처리한다.



--------------



### 7. Groq API 호출 및 응답 생성

파이썬 코드에서는 Groq 클라이언트를 사용하여 대규모 언어 모델을 호출한다.

+ 프론트엔드에서 전달된 질문을 입력으로 사용

+ 모델이 생성한 응답 텍스트를 추출

+ 불필요한 정보 없이 결과만 반환

이를 통해 AI 연산 로직이 __완전히 백엔드에 캡슐화__ 된다.



-----------



### 8. JSON 응답 반환 구조

AI 응답은 JSON 형태로 프론트엔드에 반환된다.

이 구조의 의미는 다음과 같다.

+ 프론트엔드는 응답을 쉽게 파싱 가능

+ 다른 프론트엔드나 앱에서도 동일한 API 사용 가능

+ UI와 로직의 결합도 최소화

이 JSON 응답을 JavaScript가 받아 채팅 UI에 출력하게 된다.



-------------



### 9. 서버 실행 구조

파이썬 코드 실행 시 Flask 서버가 시작된다.
서버가 실행된 이후에만 프론트엔드의 요청을 처리할 수 있다.

이 구조를 통해: 

+ 서버 미실행 상태에서의 요청 오류 방지

+ 전체 프로그램 흐름 명확화

가 이루어진다. 



--------------



### 10. 파이썬 백엔드 설계 요약

+ Flask 기반 API 서버

+ 프론트엔드와 HTTP 요청으로만 연결

+ AI 로직 완전 분리

+ JSON 기반 데이터 교환

+ 보안 고려한 환경 변수 관리



---------



### 전체 흐름 최종 정리

수식처럼 정리하면 다음과 같다.

__HTML 입력 → JavaScript(fetch) → Flask(/ask) → Groq API → Flask → JavaScript → HTML 출력__

이 구조를 통해 __프론트엔드와 백엔드가 명확히 분리된 AI 챗봇 시스템__ 이 완성된다.



--------------------





## Backend Code Explanation (Python / Flask)

### 🪧1. 필요한 라이브러리 불러오기

from flask import Flask, request, jsonify
from flask_cors import CORS
import os
from dotenv import load_dotenv
from groq import Groq

__설명__

+ Flask

→ 파이썬으로 웹 서버를 만들기 위한 프레임워크

+ request

→ 프론트엔드에서 전달된 요청 데이터를 받기 위해 사용

+ jsonify

→ 응답을 JSON 형식으로 반환하기 위해 사용

+ CORS

→ 프론트엔드의 JavaScript 요청을 허용하기 위해 사용

+ load_dotenv, os

→ .env 파일에 저장된 API 키를 불러오기 위해 사용

+ Groq

→ AI 모델을 호출하기 위한 클라이언트

### 2. 환경 변수 로드 및 API 키 설정

load_dotenv()
api_key = os.getenv("GROQ_API_KEY")

if not api_key:
    raise ValueError("API 키가 설정되지 않았습니다.")

__설명__

+ .env 파일에 저장된 환경 변수를 로드

+ GROQ_API_KEY를 읽어와 API 인증에 사용

+ 키가 없을 경우 프로그램을 중단하여 오류를 사전에 방지

__→ 보안과 안정성을 고려한 설계__


### 3. Flask 앱 및 CORS 초기화

app = Flask(__name__)
CORS(app)

__설명__

+ Flask 애플리케이션 생성

+ CORS 허용을 통해 프론트엔드의 fetch 요청이 차단되지 않도록 설정

### 4. Groq 클라이언트 생성

client = Groq(api_key=api_key)

__설명__

+ Groq API와 통신하기 위한 클라이언트 생성

+ 이후 모든 AI 응답은 이 객체를 통해 생성됨

### 5. 메인 페이지 라우트 (/)

@app.route("/")
def index():
    return open("index.html", encoding="utf-8").read()

__설명__

+ 브라우저에서 서버 주소로 접속 시 HTML 파일 반환

+ 프론트엔드 UI를 서버에서 직접 제공

### 6. AI 응답 처리 라우트 (/ask)

@app.route("/ask", methods=["POST"])
def ask():
    data = request.get_json()
    question = data.get("question")

__설명__

+ JavaScript의 fetch("/ask") 요청을 받는 부분

+ 요청 본문(JSON)에서 question 값을 추출

+ 이 값이 __프론트엔드에서 입력한 질문__

### 7. 입력값 검증

if not question:
    return jsonify({"answer": "질문이 전달되지 않았습니다."})

__설명__

+ 질문이 비어 있는 경우를 처리

+ 서버 오류를 방지하고 안정적인 동작 보장

### 8. AI 모델 호출

completion = client.chat.completions.create(
    model="llama-3.3-70b-versatile",
    messages=[
        {"role": "user", "content": question}
    ]
)

__설명__

+ 프론트엔드에서 받은 질문을 AI 모델에 전달

+ messages 구조를 통해 대화 형식으로 입력

+ 모델이 응답을 생성함

### 9. AI 응답 추출

answer = completion.choices[0].message.content

__설명__

+ AI가 생성한 결과 중 실제 텍스트만 추출

+ 불필요한 메타데이터 제거

### 10. 프론트엔드로 응답 반환

return jsonify({"answer": answer})


__설명__

+ AI 응답을 JSON 형식으로 반환

+ JavaScript에서 data.answer로 접근 가능

+ 이 응답이 채팅 UI에 출력됨

### 11. 서버 실행

if __name__ == "__main__":
    app.run(debug=True)

__설명__

+ 파이썬 파일 실행 시 Flask 서버 시작

+ 서버가 실행된 이후 프론트엔드 요청 처리 가능

## 파이썬 코드 흐름 요약

수식처럼 정리하면 다음과 같다.

__JavaScript 요청 → /ask → JSON 데이터 수신 → AI 모델 호출 → 응답 생성 → JSON 반환__

